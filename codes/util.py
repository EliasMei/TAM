import os
import torch
import json
import pickle
import numpy as np 
from graph_ae import *
from temp_graph import *
from data_processor import *

def distance_temp(obj_1, obj_2):
    """calculate the distance between two objets (nodes or edges) in temporal graph

    The distance between objects are the square of Euclidean Distance between their embeddings

    Args:
        obj_1: an object which has embedding
        obj_2: an object which has embedding
    """
    try:
        emb_1 = obj_1.get_embedding()
        emb_2 = obj_2.get_embedding()
        return np.sum(np.square(emb_1 - emb_2))
    except:
        emb_1 = obj_1[0].get_embedding() + obj_1[1].get_embedding()
        emb_2 = obj_2[0].get_embedding() + obj_2[1].get_embedding()
        return np.sum(np.square(emb_1 - emb_2))
    raise AttributeError('Wrong input')

def get_init_node_embedding(graphs, node_emb_size=100):
    """initialize node embedding
    
    If two nodes in different graphs have the same value, these two nodes will have the same initial embedding.

    Args:
        graphs: a list of graphs
        node_emb_size: node embedding size

    Returns: 
        nodes_embedding: a Tensor which denotes the initial embedding of nodes
        node_ix_dict: a dict whose key is TempNode and value is the ix in embedding 
    """
    nodes = [node for graph in graphs for _, node in graph.nodes.items()]
    node_num = len(nodes)
    node_ix_dict = {node:ix for ix, node in enumerate(nodes)}
    init_node_embedding = torch.empty(node_num, node_emb_size)
    torch.nn.init.xavier_normal_(init_node_embedding)
    return init_node_embedding

def embed_graph(graphs, model):
    """set node and edge embeddings in grpah

    Align node embedding to each node in graphs. And then, edge embedding will be generated by its head node and end ndoe.

    Args:
        graphs: a list of graphs
        model: pre-trained Graph_AutoEncoder Model
    """
    model.eval()
    nodes = [node for graph in graphs for _, node in graph.nodes.items()]
    node_ix_dict = {node:ix for ix, node in enumerate(nodes)}
    node_embeddings = model.node_embeddings.weight.data.cpu().detach().numpy()
    for graph in graphs:
        for _, node in graph.nodes.items():
            ix = node_ix_dict[node]
            embedding = node_embeddings[ix]
            node.set_embedding(embedding)
        graph.set_edge_embedding()
    return graphs

def generate_temp_graphs(dataset_name, load_data_func, times, attributes, time_diff_threshold=600, intervals=20, data_dir='~/TemeporalGraph/exp/data/wind/split', save_dir='../output/wind/', load_flag=False) :
    """generate graphs for GoldWinda data
    
    Args:
        attributes: a list of value attributes to be matched
        data_dir: the root dir of data files
        save_dir: the save dir of temp_graph.pkl
        load_flag: default is False. If we need to load saved graphs, set it to True
    
    Returns:
        all_graphs: a 3-layer list of graphs: [csv[time[attr.graph]]]
            e.x.:
            [[csv1[time_1[attr_1.graph, attr_2.graph, ...], time_2[...]], [csv1[time_1[attr_1.graph, attr_2.graph, ...], time_2[...], [...]]
    """
    if not os.path.exists(save_dir):
        os.makedirs(save_dir)
    save_path = os.path.join(save_dir, 'temp_graph.pkl')
    # load graphs
    if os.path.exists(save_path) and load_flag == True:
        with open(save_path, 'rb') as f:
            all_graphs = pickle.load(f)
        return all_graphs

    # generate graphs
    if type(data_dir) == str:
        data_files = os.listdir(data_dir)
        # data_files = sorted(os.listdir(data_dir))
        data_files = [f for f in data_files if f.count('.csv') > 0][:20]
    elif type(data_dir) == tuple:
        data_files_0 = os.listdir(data_dir[0])
        data_files_0 = [f for f in data_files_0 if f.count('.csv') > 0][:10]
        data_files_1 = os.listdir(data_dir[1])
        data_files_1 = [f for f in data_files_1 if f.count('.csv') > 0][:10]
    else:
        raise ValueError('Wrong data_dir')
    
    def load_csv_graphs(data_file, data):
        csv_graphs = []
        for time_ in times:
            time_graphs = []
            for attr in attributes:
                graph = TempDepGraph(data_file, dataset_name, time_, attr, data, time_diff_threshold, intervals)
                graph.info()
                edge_dict[graph.file_name+' - '+graph.time+' - '+graph.attr_name] ={str(key):str(edge.temp_list) for key, edge in graph.edges.items()}
                time_graphs.append(graph)
            csv_graphs.append(time_graphs)
        return csv_graphs

    all_graphs = []
    edge_dict = {}
    if type(data_dir) == str:
        for data_file in data_files:
            path = os.path.join(data_dir, data_file)
            data = load_data_func(path, attributes)
            csv_graphs = load_csv_graphs(data_file, data)
            all_graphs.append(csv_graphs)
    elif type(data_dir) == tuple:
        for ix, data_files in enumerate([data_files_0, data_files_1]):
            for data_file in data_files:
                path = os.path.join(data_dir[ix], data_file)
                data = load_data_func(path, attributes)
                csv_graphs = load_csv_graphs(data_file, data)
                all_graphs.append(csv_graphs)
    else:
        raise ValueError('Wrong data_dir')
    
    with open(save_dir+'edge_templist.json', 'w') as f:
        json.dump(edge_dict, f)

    # save graphs
    with open(save_path, 'wb') as f:
        pickle.dump(all_graphs, f)
    return all_graphs

